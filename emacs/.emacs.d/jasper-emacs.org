#+title: GNU Emacs 配置
#+author: Jasper Hsu
#+email: xcwhome@163.com
#+options: ':t toc:nil num:t author:t email:t H:5
#+startup: content indent
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

*最后修改时间 {{{latest-export-date}}}  {{{word-count}}}字.*


在Org文件里，写好了代码块，保存文件的时候，Org mode是不会帮你自动写入文件的（未来我们可以通过配置实现），现在，我们需要通过  =C-c C-v C-t= or =M-x org-babel-tangle= 命令来触发 tangle 这个动作。

#+begin_src emacs-lisp :tangle no :results none
(org-babel-tangle)
#+end_src

xx.el 已经写好了，但并没有生效，需要重启一下Emacs，让Emacs重新加载这个配置文件，才会生效。

*elisp代码执行* :
- =C-x C-e= ： ~eval-last-sexp~ 这是最常用的，每次都要移动光标到要运行的代码后面。
- =M-x eval-region= ：执行选中区域代码
- =M-x eval-buffer= ：执行当前缓冲区代码
- =M-x load-file <ENTER> FILE_NAME= ：执行指定文件代码
- =C-j= : 执行最近距离代码，并打印输出以当前位置
- =C-M-x= : runs the command eval-defun 执行整个代码块。写函数经常修改
  然后运行，如果每次跑到最外面去 =C-x C-e= ，就很麻烦。光标只要在运行的代码块里就行了。
- =M-:= : runs the command eval-expression
- =M-x ielm= 类似于ipython交互式运行

文本编辑：
- =C-x C-s= 文件保存


+ Website: <https://xuchangwei.com/lisp/jasper-emacs.html>
+ Git repositories:
  - GitHub: <https://github.com/jaspervincent/dotfiles.git>

#+toc: headlines 8 insert TOC here, with eight headline levels

* init.el(学习)
:PROPERTIES:
:HEADER-ARGS: :tangle no
:END:

开启学习
#+begin_src sh :tangle no :results none
  :PROPERTIES:
  :HEADER-ARGS: :tangle init.el
  :END:
#+end_src

** 改键
:PROPERTIES:
:CUSTOM_ID: h:learn-key
:END:

模块化配置中添加了键绑定[[#h:basic-default][(=init-basic.el= 一些默认的配置)]]


- M(eta)：统一对应键盘按键(PC/Mac)：left windows/option
- s(uper)：统一对应键盘按键(PC/Mac)：left Alt/command
- C(trl)：统一对应键盘按键(PC/Mac): Caps Lock

Mac 只需要改大写键，Windows 对齐mac的布局
- MacOS :: 在 MacOS 中, 大家可以在 =system= -> =keyboard= ->  =function
  al keys= 中调整所有功能键的键位.

1.Windows SharpKeys 改键

来把 Left Window 键改成 Left Alt 键，Left Alt 键改成 A
pp 键，大小写键改成 Ctrl 键。

官方下载：<https://github.com/randyrants/sharpkeys>，安装后 win 菜单搜
索 sharpkey，修改完成后写入注册表重新开机生效。

| 原键                 | 目标键               | 说明               |
| Caps Lock(00_3A)    | Left Ctrl(01_1D)    | 大小写键改成Ctrl键  |
| Left Alt(00_38)     | Application(E0_5D)  | 左Alt键改成App键    |
| Left Windows(E0_5B) | Left Alt(00_38)     | 左视窗键改成左Alt键 |
| Right Alt(E0_38)    | Left Windows(E0_5B) | 右Alt键改成左视窗键 |


2.配置

Emacs 默认 Alt 键就是 Meta，而 App 键我们改成 super 键，可以通过下面 的 Elisp 代码来完成。

window 配置
#+begin_src emacs-lisp
  (setq w32-apps-modifier 'super)       ; 通过SharpKeys改成了 Application
#+end_src

mac 配置
#+begin_src emacs-lisp :tangle no :results none
;;  Opt -> meta : M, Cmd -> super : s
(setq mac-option-modifier 'meta
      mac-command-modifier 'super)
#+end_src

3.定义常用操作

现在我们可以把 Mac 下面的复制、粘贴、剪切、全选等命令移植到 Emacs 中
来了，并且这一套按键是跨平台的。

#+begin_src emacs-lisp
  (global-set-key (kbd "s-a") 'mark-whole-buffer) ;;对应Windows上面的Ctrl-a 全选
  (global-set-key (kbd "s-c") 'kill-ring-save) ;;对应Windows上面的Ctrl-c 复制
  (global-set-key (kbd "s-s") 'save-buffer) ;; 对应Windows上面的Ctrl-s 保存
  (global-set-key (kbd "s-v") 'yank) ;对应Windows上面的Ctrl-v 粘贴
  (global-set-key (kbd "s-z") 'undo) ;对应Windows上面的Ctrol-z 撤销
#+end_src

** 常用配置

1.光标移动

光标的移动是编辑器中最常用的操作所以必须熟知。

- C-f 为前移一个字符， f 代表 forward。
- C-b 为后移一个字符， b 代表 backward。
- C-p 为上移至前一行， p 代表 previous。
- C-n 为上移至下一行， n 代表 next。
- C-a 为移至行首， a 代表 ahead。
- C-e 为移至行尾， e 代表 end。

同样适用于 Shell 终端里面。

2.内置功能

Emacs 功能强大，但是部分功能默认情况下并未开启。

如编辑器内显示行号可使用 M-x linum-mode 来开启。

配置文件
#+begin_src emacs-lisp
  (global-display-line-numbers-mode 1) ;显示行号 29版本。29之前用(global-linum-mode 1)
  (setq inhibit-startup-screen t) ; 尝试关掉启动界面
#+end_src

3.帮助

Emacs 是一个富文档编辑器（Self document, extensible editor）而下面的三种方法在学 习 Emacs 的过程中也非常重要。他们分别是，

C-h k 寻找快捷键的帮助信息
C-h v 寻找变量的帮助信息
C-h f 寻找函数的帮助信息

4.windows 右键菜单添加 Open With Emacs 功能

创建注册表文件 emacs-context.reg

#+begin_src sh :tangle no :results none
Windows Registry Editor Version 5.00

[HKEY_CLASSES_ROOT\*\shell]
[HKEY_CLASSES_ROOT\*\shell\openwemacs]
@="&Edit with Emacs"
[HKEY_CLASSES_ROOT\*\shell\openwemacs\command]
@="C:\\emax64\\bin\\emacsclientw.exe -n \"%1\""
[HKEY_CLASSES_ROOT\Directory\shell\openwemacs]
@="Edit &with Emacs"
[HKEY_CLASSES_ROOT\Directory\shell\openwemacs\command]
@="C:\\emax64\\bin\\emacsclientw.exe -n \"%1\""
#+end_src


使用这个 OpenWithEmacs 的功能，Emacs 需要开启 Server Mode，代码如下：
#+begin_src emacs-lisp
(server-mode 1)
#+end_src

双击注册文件。这时右键打开文件就可以选择emacs打开了。

5.补全
<<h:learn-completion-built-in>>

在我的配置中添加内置补全[[#h:completion-built-in][(=init-completion.el= 内置补全)]]

#+begin_src emacs-lisp
  ;; 内置补全功能n
  ;;(setq tab-always-indent 'complete)           ;; 使用 TAB 来列出当前补全选项
  ;;(icomplete-mode t)                         ;; 开启的，在按 M-x 时就有可选的选项了。使用 vertico-mode，关闭此项
#+end_src

6.基础Elisp

Emacs Lisp 是世界上第二古老高级编程语言 Lisp 专为 Emacs 打造的方言。官方提供了 Emacs Lisp 的[[https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html][入门]]介绍和[[https://www.gnu.org/software/emacs/manual/html_node/elisp/index.html][参考手册]]。

#+begin_src emacs-lisp :tangle no :results none
  ;; 2 + 2
  (+ 2 2)

  ;; 2 + 3 * 4
  (+ 2 (* 3 4))

  ;; 定义变量
  (setq name "username")
  (message name) ; -> "username"

  ;; 定义函数
  (defun func ()
    (message "Hello, %s" name))

  ;; 执行函数
  (func) ; C-x C-e -> Hello, username

  ;; 设置快捷键
  (global-set-key (kbd "<f1>") 'func)

  ;; 使函数可直接被调用可添加 (interactive)
  (defun func ()
    (interactive)
    (message "Hello, %s" name))
#+end_src

定义f4快速打开配置文件
#+begin_src emacs-lisp
  ;; 快速打开配置文件
  (defun open-init-file()
    (interactive)
    (find-file "~/.emacs.d/init.el"))

  ;; 这一行代码，将函数 open-init-file 绑定到 <f4> 键上
  (global-set-key (kbd "<f4>") 'open-init-file)
#+end_src

7.外观配置
<<h:learn-ui-built-in>>

我的模块化配置[[#h:ui-built-in][(=init-ui.el= 内置配置)]]

#+begin_src emacs-lisp
  ;;(toggle-frame-maximized)                   ; 全屏编辑器
  (tool-bar-mode -1)                           ; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
  (scroll-bar-mode -1)                         ; 关闭文件滑动控件
  ;; (menu-bar-mode -1)                        ; 关闭菜单栏 (不关闭，使用插件时会用到)

  (setq-default cursor-type 'bar)              ; 更改光标的样式，默认比较粗. 更多C-h v 查询帮助
  ;;(setq cursor-type 'bar)                    ; 更改光标的样式。setq当前buffer生效，不能全局生效

  ;;(set-face-attribute 'default nil :height 150) ; 修改字号，大小为16pt
  ;;让鼠标滚动更好用。默认滚动很快
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)

  (global-hl-line-mode t)                      ;; 高亮当前行
  (setq make-backup-files nil)                 ; 关闭文件自动备份。如果是有git来管理文件，备份文件没有太大意义。~ 为后缀的文件为自动生成的备份文件
  (setq auto-save-default nil)   ; 关闭自动保存文件，#为后缀的文件
  (fset 'yes-or-no-p 'y-or-n-p)                ;; 某个命令时需要输入 (yes or no) 
#+end_src

** 关于 lexical binding

#+begin_src emacs-lisp :tangle no :results none
;; 默认没有激活。在文件最开头添加文件作用域的变量设置，设置变量的绑定方式。设置在当前文件作用域内是激活的。
;; -*- lexical-binding: t -*-
(let ((x 1))    ; x is lexically bound.
  (+ x 3))
     ⇒ 4       ; 1 + 3 的值为 4

(defun getx ()
  x)            ; x is used free in this function.

(let ((x 1))    ; x is lexically bound. getx 是用不到 let 定义的 x 的
  (getx))
;;error→ Symbol's value as variable is void: x
#+end_src

关于[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Lexical-Binding.html][lexical binding]]更多的细节，可以自行阅读 Emacs 的官方文档。程序代码使用 lexical binding 会更利于并发，编辑器会执行一些优化让代码执行的更快。很多插件要求安装 lexical binding。

范例：init.el
#+begin_src emacs-lisp :tangle no :results none
;;; init.el --- Load the full configuration -*- lexical-binding: t -*-
;;; Commentary:

;; This file bootstraps the configuration, which is divided into
;; a number of other files.

;;; Code:

(+ 1 2)

;;; init.el ends here
#+end_src

三个分号开头的注释表示“节”，两个分号开头的注释表示“段落”。（一个分号开头的是一行代码后面的行内注释）。

** 插件源

#+begin_src emacs-lisp
  (require 'package)
  (setq package-check-signature nil 
        load-prefer-newer t) ;; 个别时候会出现签名校验失败
  (setq package-archives
            '(("melpa"  . "https://melpa.org/packages/")
              ("gnu"    . "https://elpa.gnu.org/packages/")
              ("nongnu" . "https://elpa.nongnu.org/nongnu/")))

  (unless (bound-and-true-p package--initialized)
    (package-initialize)) ;; 刷新软件源索引

  ;;防止反复调用 package-refresh-contents 会影响加载速度
  (when (not package-archive-contents)
    (package-refresh-contents))

  ;;modeline上显示我的所有的按键和执行的命令
  (package-install 'keycast) ;包会安装在elpa目录中
  (keycast-mode-line-mode t)
#+end_src

** 安装补全插件

*Company插件*
<<h:learn-completion-company>>

我的emacs模块配置[[#h:completion-company][(=init-completion.el= Company)]]

他是一个用于代码补全的插件

#+begin_src emacs-lisp
  ;; 开启全局 Company 补全
  (package-install 'company)
  (global-company-mode 1)

  ;; company mode 默认选择上一条和下一条候选项命令 M-n M-p
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
#+end_src

*增强 minibuffer 补全：vertico 和 Orderless*
<<h:learn-completion-minibuffer-1>>

我的emacs模块配置[[#h:completion-minibuffer-1][(=init-completion.el= 增强 minibuffer 补全：vertico 和 Orderless)]]

#+begin_src emacs-lisp
  (package-install 'vertico)
  (vertico-mode t)

  (package-install 'orderless)
  (setq completion-styles '(orderless))
#+end_src

有了 vertico-mode，把之前的 icomplete-mode 关掉。 补全变为垂直，垂直对于我们是更友好的，所有 minibuffer 的行为的可以补全。如使用 =M-x= 补全变为垂直,  =C-x C-f= 增强显示目录下文件、 =C-x b= 变为垂直。

orderless 支持 =M-x= 模糊搜索，可以无序的。 如 edebug-defun 函数搜索， =M-x fun debug=


*配置 Marginalia 增强 minubuffer 的 annotation*
<<h:learn-completion-minibuffer-2>>

我的emacs模块配置[[#h:completion-minibuffer-2][(=init-completion.el= 配置 Marginalia 增强 minubuffer 的 annotation)]]

#+begin_src emacs
(package-install 'marginalia)
(marginalia-mode t)
#+end_src

=M-x= 可以看到它会把命令的注释直接显示在minibuffer中

=C-h v= 查看一个变量的内容，可以发现不用再按回车看到里面的值。直接显示在minibuffer中

=C-h f= 键位绑定都已经在minibuffer中显示出来了

=C-x C-f= 显示文件大小权限等， =C-x b= 显 buffer 大小状态， =C-h f= 显示函数快捷键等

*minibuffer action 和自适应的 context menu：Embark*
<<h:learn-completion-minibuffer-3>>

我的emacs模块配置[[#h:completion-minibuffer-3][(=init-completion.el= minibuffer action 和自适应的 context menu：Embark)]]


#+begin_src emacs-lisp
(package-install 'embark)
(global-set-key (kbd "C-;") 'embark-act)
(setq prefix-help-command 'embark-prefix-help-command)
#+end_src

使用

光标在函数位置，按 =C-;= 
- RET 查看光标处函数定义文件位置，并打开
- c 修改变量的值
  - 如 C-h v 变量名，按 C-; c 修改变量的值

优点：不需要记快捷键了
- 以前查看函数的绑定键
  - ~C-h b~ 查看函数快捷键绑定：
  - 以前按 =C-x C-h= 时，会告诉你 =C-x= 绑定了哪些快捷键
- 设置了 =(setq prefix-help-command #'embark-prefix-help-command)= 后
  - 按 =C-x C-h= 模糊输入函数名可看到绑定的快捷键，按回车可直接执行命令，就不需要再记快捷键了

*增强文件内搜索和跳转函数定义：Consult*
<<h:learn-completion-minibuffer-4>>

我的emacs模块配置[[#h:completion-minibuffer-4][(=init-completion.el= 增强文件内搜索Consul)]]

#+begin_src emacs-lisp
  (package-install 'consult)
  ;;replace swiper 可以替代老的 ivy mode 的 swiper 功能
  (global-set-key (kbd "C-s") 'consult-line)
  (global-set-key (kbd "M-s i") 'consult-imenu)  ;跳转函数定义
#+end_src

使用 =C-s= 搜索的内容就会在minibuffer中垂直显示，使用C-p 或 C-n来上下选择

使用 =M-s i= 跳转函数定义或者org-mode标题

这些组合可以秒杀ivy helm这种一统的插件。

*括号*

#+begin_src emacs-lisp
  (electric-pair-mode t)                       ; 括号补全
  (add-hook 'prog-mode-hook #'show-paren-mode) ;; 编程模式下，光标在括号上时高亮另一个括号
#+end_src

** 手工安装插件

以 [[https://github.com/manateelazycat/awesome-tab][awesome-tab]]  为例

创建目录，使用内容Dir包。 =C-x d= 回车， =+= 创建目录输入目录名site-lisp 回车， =q= 退出

使用 =M-x eshell= 克隆代码
#+begin_src sh :tangle no :results none
cd site-lisp
git clone --depth=1 https://github.com/manateelazycat/awesome-tab.git
#+end_src

配置文件
#+begin_src emacs-lisp :tangle no :results none
(add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/awesome-tab/"))
(require 'awesome-tab)
(awesome-tab-mode t)

(defun awesome-tab-buffer-groups ()
"`awesome-tab-buffer-groups' control buffers' group rules.
Group awesome-tab with mode if buffer is derived from `eshell-mode' `emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `awesome-tab-get-group-name' with project name."
(list
(cond
    ((or (string-equal "*" (substring (buffer-name) 0 1))
	(memq major-mode '(magit-process-mode
			    magit-status-mode
			    magit-diff-mode
			    magit-log-mode
			    magit-file-mode
			    magit-blob-mode
			    magit-blame-mode)))
    "Emacs")
    ((derived-mode-p 'eshell-mode)
    "EShell")
    ((derived-mode-p 'dired-mode)
    "Dired")
    ((memq major-mode '(org-mode org-agenda-mode diary-mode))
    "OrgMode")
    ((derived-mode-p 'eaf-mode)
    "EAF")
    (t
    (awesome-tab-get-group-name (current-buffer))))))
#+end_src

** 其他小配置

*最近打开文件*

最近打开过文件的选项让我们更快捷的在图形界面的菜单中打开最近 编辑过的文件。

#+begin_src emacs-lisp
(require 'recentf)
(recentf-mode 1)
(setq recentf-max-menu-item 10)

;; 这个快捷键绑定可以用之后的插件 counsel 代替
;; (global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+end_src

使用下面的配置文件将删除功能配置成与其他图形界面的编辑器相同，即当你选中一段文字 之后输入一个字符会替换掉你选中部分的文字。

#+begin_src emacs-lisp
  (delete-selection-mode t)                    ;; 选中文本后输入文本会替换文本（更符合我们习惯了的其它编辑器的逻辑。默认选中放后面
#+end_src

下面的这些函数可以让你找到不同函数，变量以及快捷键所定义的文件位置。 因为非常常用 所以我们建议将其设置为与查找文档类似的快捷键（如下所示），

可以把它们绑定到配置中

#+begin_src emacs-lisp
  ;; 查询函数、变量、key 定义的文件位置
  (global-set-key (kbd "C-h C-f") 'find-function)
  (global-set-key (kbd "C-h C-v") 'find-variable)
  (global-set-key (kbd "C-h C-k") 'find-function-on-key)
#+end_src

** Emacs作为超级前端

可以非常快的找到文件或目录

*** 使用 Emacs 来打开文件管理器
:PROPERTIES:
:CUSTOM_ID: h:learn-funcs-front-explorer
:END:
我的emacs模块配置[[#h:funcs-front-explorer][(=init-funcs.el= 超级前端-打开PC文件管理)]]

windows 用户

#+begin_src emacs-lisp :tangle no :results none
  (shell-command-to-string "explorer.exe C:\\")

  ;;(shell-command-to-string "explorer.exe ~/.emacs.d") ; windows 不识别~

  (shell-command-to-string
   (encode-coding-string
    (replace-regexp-in-string "/" "\\\\\\\\"
                  (format "explorer.exe %s" (expand-file-name "~/.emacs.d")))
    'gbk))
#+end_src

#+begin_src emacs-lisp
  (defun consult-directory-externally (file)
    "Open FILE externally using the default application of the system."
    (interactive "fOpen externally: ")
    (if (and (eq system-type 'windows-nt)
             (fboundp 'w32-shell-execute))
        (shell-command-to-string (encode-coding-string (replace-regexp-in-string "/" "\\\\\\\\"
              (format "explorer.exe %s" (file-name-directory (expand-file-name file)))) 'gbk))
      (call-process (pcase system-type
                      ('darwin "open")
                      ('cygwin "cygstart")
                      (_ "xdg-open"))
                    nil 0 nil
                    (file-name-directory (expand-file-name file)))))

  (require 'embark)
  (define-key embark-file-map (kbd "E") #'consult-directory-externally)


  ;;打开当前文件的目录
  (defun my-open-current-directory ()
    (interactive)
    (consult-directory-externally default-directory))
#+end_src

快速打开文件所在目录：
- =M-x consult-directory-externally= 输入文件路径，如 =~/.emacs.d/auto-save-list/.saves-2000-JASPER~=
- =C-x C-f= 选择文件时，可以用embark来打开， =C;= 选择E，用文件管理器打开对应目录的

*** 增强 embark 和 consult，批量搜索替换大杀器
:PROPERTIES:
:CUSTOM_ID: h:learn-completion-minibuffer-4-1
:END:

我的emacs模块配置[[#h:completion-minibuffer-4-1][(=init-completion.el= 增强 embark 和 consult，批量搜索替换大杀)]]

性能： grep < ack < ag < ripgrep(rg)

使用ripgrep来进行搜索, =M-x consult-ripqgrep= 搜索hello 会出现报错找不到rg命令。

#+begin_example
Error running timer: (file-missing "Searching for program" "No such file or directory" "rg")
#+end_example

下载ripgrep: <https://github.com/BurntSushi/ripgrep> msys2 <https://packages.msys2.org/base/mingw-w64-ripgrep>

安装方式：
- PC msys2 ~pacman -S mingw-w64-x86_64-ripgrep~
- PC github release 下载windows包，解压并加入到PARH变量中
- Arch Linux  ~sudo pacman -S ripgrep~
- macOS ~brew install ripgrep~

再使用ripgrep来进行搜索, =M-x consult-ripgrep= 搜索hello ，所有当前目录下包含hello字符串的信息都在minibuffer中展示出来了。 使用 =C-n= 或 =C-p= 来预览文件或进入文件里。

*下面介绍批量修改插件*
#+begin_src emacs-lisp
  ;; 批量修改
  (package-install 'embark-consult)
  (package-install 'wgrep)
  (setq wgrep-auto-save-buffer t)

  (eval-after-load 'consult
    '(eval-after-load 'embark
       '(progn
          (require 'embark-consult)
          (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode)))) ;hook 第一个参数执行前，先执行第2个参数的功能

  (define-key minibuffer-local-map (kbd "C-c C-e") 'embark-export-write)

  (defun embark-export-write ()
    "Export the current vertico results to a writable buffer if possible.
  Supports exporting consult-grep to wgrep, file to wdeired, and consult-location to occur-edit"
    (interactive)
    (require 'embark)
    (require 'wgrep)
    (pcase-let ((`(,type . ,candidates)
                 (run-hook-with-args-until-success 'embark-candidate-collectors)))
      (pcase type
        ('consult-grep (let ((embark-after-export-hook #'wgrep-change-to-wgrep-mode))
                         (embark-export)))
        ('file (let ((embark-after-export-hook #'wdired-change-to-wdired-mode))
                 (embark-export)))
        ('consult-location (let ((embark-after-export-hook #'occur-edit-mode))
                             (embark-export)))
        (x (user-error "embark category %S doesn't support writable export" x)))))
#+end_src

批量替换操作
- ~M-x consult-ripgrep~  默认会在以 git 为根目录搜索。如 =#hello= ，搜索包含hello字符的文件。 ~C-n/C-p~ 下上搜索同时可以预览。
- ~C-c C-e~ 打开写
- ~M-x query-replace-regexp~ 输入hello 回车， 替换为hello 回车。 按 y 同意当前行替换，n 不同意修改
- ~C-c C-c~ 执行替换，按 q 退出


当前buffer替换操作
- =C-s= 搜索， 输入hello
- =C-c C-e= 编辑
- ~M-x query-replace-regexp~ 输入要替换的内容
- ~C-c C-c~ 执行替换，按 q 退出

*配置搜索中文文件*

everythin工具可以快速搜索本地文件。下载地址： <https://www.voidtools.com/zh-cn/downloads/>

安装好后，同时下载 ES.exe 客户端工具加入环境变量。


#+begin_src emacs-lisp
;;everyting
;;consult-locate
;; 配置搜索中文文件
(progn
  (setq consult-locate-args (encode-coding-string "es.exe -i -p -r" 'gbk))
  (add-to-list 'process-coding-system-alist '("es" gbk . gbk))
  )
(eval-after-load 'consult
  (progn
      (setq
        consult-narrow-key "<"
        consult-line-numbers-widen t
        consult-async-min-input 2         ;; 搜索 2 个字符显示输出。默认 3
        consult-async-refresh-delay  0.15
        consult-async-input-throttle 0.2
        consult-async-input-debounce 0.1)
    ))
#+end_src

操作：
- 前提：PC 始终打开everything, 转为ES会调用everthing
- =M-x consult-locate= 回车，输入要搜索的文件如 =#init.el= 。 可以看到minibuffer中显示的和everthing界面搜索的是一样的。
- 再输入个#号就可以使用 orderless 的功能进行过滤。如只想看29.4中init.el文件 =#init.el#29.4= 选中回车即可打开对应文件

使用外部程序打开：
- =M-x consult-locate= 回车，输入要搜索的文件. 如搜索projeckt中的txt文件 =#\.txt#project=
- 使用embark =C;=  按x使用外部程序打开txt文件

中文搜索操作：
- =M-x consult-locate= 回车，输入要搜索的文件. 如 =#学习=

*** 使用拼音进行搜索
:PROPERTIES:
:CUSTOM_ID: h:learn-tools-search-pinyin
:END:

我的emacs模块配置[[#h:tools-search-pinyin][(=init-tools.el= 使用拼音进行搜索)]]

#+begin_src emacs-lisp
  ;; 使用拼音进行搜索
  (package-install 'pyim)

  (defun eh-orderless-regexp (orig_func component)
    (let ((result (funcall orig_func component)))
      (pyim-cregexp-build result)))


  (defun toggle-chinese-search ()
    (interactive)
    (if (not (advice-member-p #'eh-orderless-regexp 'orderless-regexp))
        (advice-add 'orderless-regexp :around #'eh-orderless-regexp)
      (advice-remove 'orderless-regexp #'eh-orderless-regexp)))

  (defun disable-py-search (&optional args)
    (if (advice-member-p #'eh-orderless-regexp 'orderless-regexp)
        (advice-remove 'orderless-regexp #'eh-orderless-regexp)))

  ;; (advice-add 'exit-minibuffer :after #'disable-py-search)
  (add-hook 'minibuffer-exit-hook 'disable-py-search) ;退出minibuffer时自动退出拼音搜索

  (global-set-key (kbd "s-p") 'toggle-chinese-search) ;需要时打开拼音搜索。因为拼音搜索性能不稳定
#+end_src

中文拼音操作：
- 前提：PC 始终打开everything, 转为ES会调用everthing
- =M-x consult-locate= 回车，输入要搜索的文件. 如打包含“学习”的txt文件 =#\.txt#= 按 =s-p= 输入 =#\.txt#xx=  可以看到过滤学习的txt文件

*** 更换主题

customize theme 内置主题

自带的主题颜色，可以使用 =M-x customize themes= 图形化来选择，或者使用命令 =load-theme 主题= 。如 =M-x load-theme light-blue=

- leuven，我最喜欢的亮色主题之一了。其实它也有暗色主题，只是没有内置。
- modus，应该是从Emacs 28开始内置的一款包含亮/暗色的主题。非常好，我很喜欢。暗色有的时候，我感觉眼睛有点累。

#+begin_src emacs-lisp
  (load-theme 'tango-dark)
#+end_src

** 模块化配置

*** 使用多文件存储配置文件

创建 custom.el 文件

一些自动生成的配置会自动写到这里。默认是写到init.el文件结尾的。

#+begin_src emacs-lisp
  (setq custom-file (expand-file-name "~/custom.el")) ;没有则自动创建
  (load custom-file 'no-error 'no-message)
#+end_src

拆分init.el文件

#+begin_example
  ├── init.el
  ├── lisp
  │  ├── init-basic.el      # 基础配置
  │  ├── init-elpa.el       # 插件源
  │  ├── init-org.el        # org mode
  │  ├── init-recentf.el    # 最近打开文件  
  │  ├── init-site-lisp.el  # 非 elpa 源
  │  ├── init-themes.el     # 主题
  │  └── init-utils.el      # 自定义工具

  #----------
  ├── custom.el
  ├── early-init.el
  ├── init.el
  ├── lisp
  │   ├── init-basic.el           #默认的配置
  │   ├── init-c.el
  │   ├── init-completion.el     #补全
  │   ├── init-const.el
  │   ├── init-custom.el
  │   ├── init-funcs.el          #自定义函数
  │   ├── init-keybindings.el
  │   ├── init-lisp.el
  │   ├── init-org.el
  │   ├── init-package.el        #插件源
  │   ├── init-tools.el
  │   ├── init-ui.el             #视觉相关
  │   └── init-writing.el
#+end_example

加载配置
#+begin_src emacs-lisp
(add-to-list 'load-path
    (expand-file-name (concat user-emacs-directory "lisp")))
#+end_src

各个文件通过 provide 暴露对外调用的名称。如：
#+begin_src emacs-lisp :tangle no :results none
(provide 'init-basic)
#+end_src

然后在 init.el 文件中通过 `require` 调用：
#+begin_src emacs-lisp :tangle no :results none
require 'init-basic
#+end_src

*** 使用Org-mode 管理 Emacs 配置

Org-mode 下的文学编程将颠覆你对于 Emacs 的看法。因为我们也可以使用 Org 来管理 Emacs 的配置文件。

我们可以让我们的配置文件更加清晰有序，并且可以添加很多注释之外的资料、链接等，让我们的配置更加易读和可管理。


- 创建org文件。如 =~/.emacs.d/emacs-config.org=
- 代码块
  它能够自动的将代码块里的代码，写入到指定的文件里去，不指定默认在当前目录生成与文件同名.el文件。
  
  而且它的配置方式也非常灵活：
  - 代码块配置tangle
  - 标题行配置tangle

- 执行 ~M-x org-babel-tangle~ 命令来触发 tangle 这个动作。

范例-代码块配置tangle

#+begin_src sh :tangle no :results none
  ,#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/test.el
    (+ 1 2)
  ,#+END_SRC
#+end_src

执行 ~M-x org-babel-tangle~ ，代码 (+ 1 2) 将写入到 ~/.emacs.d/test.el 这个文件里。

范例-标题行配置tangle
#+begin_src sh :tangle no :results none
  ,* early-init.el
  :PROPERTIES:
  :HEADER-ARGS: :tangle early-init.el
  :END
#+end_src

不想写入文件
- 直接在对应代码块或者标题参数行写上 :tangle no
  
*添加代码块*

- 旧版使用快捷键 ~< + 快捷码 + TAB~ 。
  - 如代码块 ~<s + Tab~ 可以直接插入代码块的代码片段（Snippet）
- 从 orgmode 9.2 版本后， ~org-insert-structure-template~ 变为 ~C-c C-,~ 给出列表选择


还想使用旧版快捷键
<<h:learn-org-built-in>>

我的emacs模块配置[[#h:org-built-in][(=init-org.el= 内置配置)]]


#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-tempo))

  ;; 禁用左尖括号
  (setq electric-pair-inhibit-predicate
        `(lambda (c)
           (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))

  (add-hook 'org-mode-hook
            (lambda ()
              (setq-local electric-pair-inhibit-predicate
                          `(lambda (c)
                             (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))))
#+end_src

** 模块列表

*** 1

*文件搜索键位绑定*

[[#h:keybindings-search-file][我的emacs模块配置(=init-keybindings.el= 文件搜索)]]

*** 2
*一些好用的包*

- restart-emacs

- savehist 记住使用过的命令[[#h:basic-session][(=init-basic.el= 保存会话)]]

- 显示文件行、列、大小 ，美化状态栏
  - simple[[#h:basic-simple][(=init-basic.el= simple)]]
  - keycast[[#h:tools-keycast][(=init-tools.el= keycast)]]
  - doom-modeline [[#h:ui-doom-emacs][(=init-ui.el= doom-emacs)]]
*** org

- org
  - org todo[[#h:org-todo][(=init-org.el= org todo)]]
  - org agenda[[#h:org-agenda][(=init-org.el= org agenda)]]
  - org capture[[#h:org-capture][(=init-org.el= org capture)]]
  - org effect[[#h:org-effect][(=init-org.el= org effect)]]
  - org tags[[#h:org-tags][(=init-org.el= org tags)]]
  - org priority[[#h:org-priority][(=init-org.el= org priority)]]
*** 4

- ox-hugo来写博客
- eglot emacs29版本内置


** 清理学习内容
#+begin_src emacs-lisp :tangle no
  (write-region "" nil "~/.emacs.d/init.el")
#+end_src


* Emacs初始化 =early-init.el=
:PROPERTIES:
:HEADER-ARGS: :tangle early-init.el
:END:

这是 Emacs 在启动时读取的第一个文件。它应该包含不依赖于任何包或 Emacs 帧比例的代码。初始化文件是为了在 Emacs 生成初始帧之前设置一些基本的东西

** =early-init.el= 对启动时间和垃圾回收的调整

#+begin_src emacs-lisp :tangle "early-init.el"
  (setq gc-cons-threshold (* 50 1000 1000))
#+end_src

** =early-init.el= 初始化包缓存
:PROPERTIES:
:CUSTOM_ID: h:package-cache
:END:


这里使用标准的 =package.el= 来管理我的Emacs包。
([[#h:package.el][=init.el= 配置软件包]])

* Emacs主配置文件 (=init.el=)

#+begin_src emacs-lisp :tangle "init.el"
  ;;; init.el --- The main init entry for Emacs -*- lexical-binding: t -*-
  ;;; Commentary:

  ;; This file bootstraps the configuration, which is divided into
  ;; a number of other files.

  ;;; Code:

  
#+end_src

** =init.el= 基础配置禁用备份和锁定文件

默认情况下，Emacs 会尝试锁定文件，以免它们被其他程序修改。它还保留备份。这些是我不需要的功能

#+begin_src emacs-lisp :tangle "init.el"
  ;; 禁用备份和锁定文件
  (setq make-backup-files nil)
  (setq backup-inhibited nil) ; Not sure if needed, given `make-backup-files'
  (setq create-lockfiles nil)
#+end_src

** =init.el= 指定自定义文件 custom.el

默认情况下，Emacs 将持久自定义写入用户的 init 文件末尾。当用户 =M-x customize= 或与之相关时，Emacs 都会写这些内容。指定自定义文件位置与init.el区分开。

#+begin_src emacs-lisp :tangle "init.el"
  ;; 指定自己义配置
  (setq custom-file (make-temp-file "emacs-custom-")) ;没有则自动创建emacs-custom-开头随机文件
  (load custom-file 'no-error 'no-message)
#+end_src

** =init.el= 始终从 =*scratch*= 缓冲区开始

#+begin_src emacs-lisp :tangle "init.el"
  ;; 始终从 *scratch* 缓冲区开始
  (setq initial-buffer-choice t)
#+end_src

** =init.el= 加载目录
:PROPERTIES:
:CUSTOM_ID: h:i-dir
:END:


加载目录下所有配置
- =list= 目录 :: 各种插件配置
- =person= 目录 :: 个人的配置

在 =init.el= 配置中调用插件[[#h:i-modules][(=init.el= 加载各模块)]]
  

#+begin_src emacs-lisp :tangle "init.el"
  ;; 加载目录
  (mapc
   (lambda (string)
     (add-to-list 'load-path (locate-user-emacs-file string)))
   '("lisp" "person"))
#+end_src

** =init.el= 软件包 (=package.el=)
:PROPERTIES:
:CUSTOM_ID: h:package.el
:END:

package.el 内置于 Emacs 中。我们不需要显式加载它，在需要时会被 use-package 调用。
early-init.el 处激活缓存[[#h:package-cache][(=early-init.el= 初始化包缓存)]]

#+begin_src emacs-lisp :tangle "init.el"
  ;;;; 软件包

  (setq package-vc-register-as-project nil) ; Emacs 30

  ;; 设置插件源优先级
  (require 'package)
  (setq package-check-signature nil 
        load-prefer-newer t) ;; 个别时候会出现签名校验失败
  (setq package-archives
        '(("gnu-elpa" . "https://elpa.gnu.org/packages/")
          ("gnu-elpa-devel" . "https://elpa.gnu.org/devel/")
          ("nongnu" . "https://elpa.nongnu.org/nongnu/")
          ("melpa" . "https://melpa.org/packages/")))

  ;; 最大的数字优先（未提及的优先级为 0）
  (setq package-archive-priorities
        '(("gnu-elpa" . 3)
          ("melpa" . 2)
          ("nongnu" . 1)))

  (unless (bound-and-true-p package--initialized)
    (package-initialize)) ;; 刷新软件源索引

  ;;防止反复调用 package-refresh-contents 会影响加载速度
  (when (not package-archive-contents)
    (package-refresh-contents))
#+end_src

强制指定某些软件的源
#+begin_src emacs-lisp :tangle "init.el"
  (defvar prot-emacs-my-packages
    '(vertico tmr)
    "List of symbols representing the packages I develop/maintain.")

  ;; 指定某些软件使用特点源安装 
  (setq package-pinned-packages
        `(,@(mapcar
             (lambda (package)
               (cons package "gnu-elpa-devel"))
             prot-emacs-my-packages)))
#+end_src

** =init.el= 加载各个模块
:PROPERTIES:
:CUSTOM_ID: h:i-modules
:END:

我把配置拆分为几个模块[[#h:i-dir][(=init.el= 加载目录)]]

各个模块都记录在下面[[#h:modules][我的 Emacs 模块配置]]中


#+begin_src emacs-lisp :tangle "init.el"
  ;; 加载模块
  (load (locate-user-emacs-file "jasper-emacs-pre-custom.el") :no-error :no-message)

  (require 'init-basic)
  (require 'init-packages)
  (use-package benchmark-init
    :ensure t
    :demand t
    :config
    ;; To disable collection of benchmark data after init is done.
    (add-hook 'after-init-hook 'benchmark-init/deactivate))
  (require 'init-evil)
  (require 'init-completion)
  (require 'init-tools)
  (require 'init-ui)
  (require 'init-org)
  (require 'init-keybindings)
  (require 'init-programming)
  (require 'init-evil)
  (require 'init-window)
  (require 'init-funcs)

  (load (locate-user-emacs-file "jasper-emacs-post-custom.el") :no-error :no-message)
#+end_src

** =init.el= 计算启动时间

#+begin_src emacs-lisp :tangle "init.el"
  (defun efs/display-startup-time ()
    (message "Emacs loaded in %s with %d garbage collections."
             (format "%.2f seconds"
                     (float-time
                     (time-subtract after-init-time before-init-time)))
             gcs-done))

  (add-hook 'emacs-startup-hook #'efs/display-startup-time)


  (setq gc-cons-threshold (* 2 1000 1000))
#+end_src


* 我的Emacs模块配置
:PROPERTIES:
:CUSTOM_ID: h:modules
:END:

=init.el= 部分中，通过 ~load-path~ 让 Emacs 可以运行他们的代码[[#h:i-dir][(=init.el= 加载目录)]]。本章的副标题定义了模块，每个模块都加载在我的 =init.el= 末尾调用[[#h:i-modules][(=init.el= 加载各模块)]]

** =init-basic.el=
*** =init-basic.el= 一些默认的配置
:PROPERTIES:
:CUSTOM_ID: h:basic-default
:END:

这里涉及到改键[[#h:learn-key][(改键)]]

#+begin_src emacs-lisp :tangle "lisp/init-basic.el" :mkdirp yes
  ;;; 一些默认的配置

  (setq w32-apps-modifier 'super)       ;PC 通过SharpKeys改成了 Application

  ;;; 统一配置
  (global-set-key (kbd "s-a") 'mark-whole-buffer) ;;对应Windows上面的Ctrl-a 全选
  (global-set-key (kbd "s-c") 'kill-ring-save) ;;对应Windows上面的Ctrl-c 复制
  (global-set-key (kbd "s-s") 'save-buffer) ;; 对应Windows上面的Ctrl-s 保存
  (global-set-key (kbd "s-v") 'yank) ;对应Windows上面的Ctrl-v 粘贴
  (global-set-key (kbd "s-z") 'undo) ;对应Windows上面的Ctrol-z 撤销

  ;; 查询函数、变量、key 定义的文件位置
  (global-set-key (kbd "C-h C-f") 'find-function)
  (global-set-key (kbd "C-h C-v") 'find-variable)
  (global-set-key (kbd "C-h C-k") 'find-function-on-key)

  ;; 设置系统的编码，避免各处的乱码
  ;; UTF-8 as the default coding system
  (when (fboundp 'set-charset-priority)
    (set-charset-priority 'unicode))
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)

  ;; 开启服务
  ;;(server-mode 1)

  (electric-pair-mode t)                       ; 括号补全
  (add-hook 'prog-mode-hook #'show-paren-mode) ; 编程模式下，光标在括号上时高亮另一个括号
  (delete-selection-mode t)                    ; 选中文本后输入文本会替换文本（更符合我们习惯了的其它编辑器的逻辑。默认选中放后面

  (global-auto-revert-mode t)                  ; 自动加载外部修改过的文件
  (setq auto-save-default nil)                 ; 关闭自动保存文件，#为后缀的文件
  (setq ring-bell-function 'ignore)            ; 关闭提示声音
  (fset 'yes-or-no-p 'y-or-n-p)                ;; 某个命令时需要输入 (yes or no)
#+end_src

*** =init-basic.el= 最近编辑过的文件

#+begin_src emacs-lisp :tangle "lisp/init-basic.el"
  ;;; 最近编辑过的文件
  (use-package recentf
    :ensure nil
    :bind (("C-x C-r" . recentf-open-files))
    :hook (after-init . recentf-mode)
    :init (setq recentf-max-saved-items 300
                recentf-exclude
                '("\\.?cache" ".cask" "url" "COMMIT_EDITMSG\\'" "bookmarks"
                  "\\.\\(?:gz\\|gif\\|svg\\|png\\|jpe?g\\|bmp\\|xpm\\)$"
                  "\\.?ido\\.last$" "\\.revive$" "/G?TAGS$" "/.elfeed/"
                  "^/tmp/" "^/var/folders/.+$" "^/ssh:" "/persp-confs/"
                  (lambda (file) (file-in-directory-p file package-user-dir))))
    :config
    (push (expand-file-name recentf-save-file) recentf-exclude)
    (add-to-list 'recentf-filename-handlers #'abbreviate-file-name))
#+end_src

*** =init-basic.el= 保存会话
:PROPERTIES:
:CUSTOM_ID: h:basic-session
:END:

savehist-mode  默认开启，重启 emacs 会记住使用过的命令，同时会保存到 =~/.emacs.d/history= 文件中。 history 文件还保存了 minibuffer 的变量、查找过的文件等。相当于记住了上次的工作状态。

save-place-mode 开启后，会记住光标所在文件的位置，下次打开文件时自动光标指向这个位置


#+begin_src emacs-lisp :tangle "lisp/init-basic.el"
  ;;; Save and restore editor sessions between restarts
  ;; 记住使用过的命令
  (use-package savehist
    :ensure nil
    :hook (after-init . savehist-mode)
    :init (setq enable-recursive-minibuffers t ; Allow commands in minibuffers
                history-length 1000
                savehist-additional-variables '(mark-ring
                                                global-mark-ring
                                                search-ring
                                                regexp-search-ring
                                                extended-command-history)
                savehist-autosave-interval 300)
    )

  ;; 记住光标所在文件的位置
  (use-package saveplace
    :ensure nil
    :hook (after-init . save-place-mode)) ;在emacs配置完全加载好以后，执行save-place-mode
#+end_src

测试：
- 记住光标的位置，重启emacs
- =C-x C-f= 重新打开该文件，可以看到光标是上次退出的位置。

*** =init-basic.el= simple
:PROPERTIES:
:CUSTOM_ID: h:basic-simple
:END:

modeline上显示文件大小、列号

#+begin_src emacs-lisp :tangle "lisp/init-basic.el"
  ;;; modeline上显示文件大小、 列号
  (use-package simple
    :ensure nil
    :hook (after-init . size-indication-mode)
    :init
    (progn
      (setq column-number-mode t)
      ))
#+end_src

*** =init-basic.el= general
:PROPERTIES:
:CUSTOM_ID: h:basic-general
:END:

在自定义evil键位绑定用到[[#h:evil-custom-keybinding][(=init.evil.el= 自定义快捷键)]]

#+begin_src emacs-lisp :tangle "lisp/init-basic.el"
  (use-package general
    :ensure t
    :init
    ;; 针对evil插件。设置了一些类似leader键的函数. 如 leader 为空格对应函数global-definer , leader 为逗号对应函数global-leader
    (with-eval-after-load 'evil
      (general-add-hook 'after-init-hook
                        (lambda (&rest _)
                          (when-let ((messages-buffer (get-buffer "*Messages*")))
                            (with-current-buffer messages-buffer
                              (evil-normalize-keymaps))))
                        nil
                        nil
                        t))


    (general-create-definer global-definer
      :keymaps 'override
      :states '(insert emacs normal hybrid motion visual operator)
      :prefix "SPC"
      :non-normal-prefix "C-SPC")

    ;; 定义一个宏。这个宏的作用是继承global-dfiner函数的leader键SPC空格，接收一个inix-key变量的值为子leader
    (defmacro +general-global-menu! (name infix-key &rest body)
      "Create a definer named +general-global-NAME wrapping global-definer.
  Create prefix map: +general-global-NAME. Prefix bindings in BODY with INFIX-KEY."
      (declare (indent 2))
      `(progn
         (general-create-definer ,(intern (concat "+general-global-" name))
           :wrapping global-definer
           :prefix-map ',(intern (concat "+general-global-" name "-map"))
           :infix ,infix-key
           :wk-full-keys nil
           "" '(:ignore t :which-key ,name))
         (,(intern (concat "+general-global-" name))
          ,@body)))

    (general-create-definer global-leader
      :keymaps 'override
      :states '(emacs normal hybrid motion visual operator)
      :prefix ","
      "" '(:ignore t :which-key (lambda (arg) `(,(cadr (split-string (car arg) " ")) . ,(replace-regexp-in-string "-mode$" "" (symbol-name major-mode)))))))
#+end_src

*** =init-basic.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-basic.el"
  (message "Load init-basic done...")
  (provide 'init-basic)
#+end_src

** =init-packages.el=

*** =init-packages.el= 安装

#+begin_src emacs-lisp :tangle "lisp/init-packages.el" :mkdirp yes
  ;; make use-package default behavior better
  ;; with `use-package-always-ensure' you won't need ":ensure t" all the time
  ;; with `use-package-always-defer' you won't need ":defer t" all the time
  (setq use-package-always-ensure t
        use-package-always-defer t
        use-package-enable-imenu-support t
        use-package-expand-minimally t)
  (require 'use-package)
#+end_src

*** =init-package.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-packages.el"
  (message "Load init-packages done...")
  (provide 'init-packages)
#+end_src

** =init-evil.el=

*** =init-evil.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  (message "Load init-evil done...")
  (provide 'init-evil)
#+end_src

** =init-completion.el=

*** =init-completion.el= 内置补全
:PROPERTIES:
:CUSTOM_ID: h:completion-built-in
:END:

在学习章节提到过[[h:learn-completion-built-in][(补全)]]

#+begin_src emacs-lisp :tangle "lisp/init-completion.el" :mkdirp yes
  ;; 内置补全功能n
  ;;(setq tab-always-indent 'complete)           ;; 使用 TAB 来列出当前补全选项
#+end_src

*** =init-completion.el= Company
:PROPERTIES:
:CUSTOM_ID: h:completion-company
:END:

在学习章节提到过[[h:learn-completion-company][(Company插件)]]


他是一个用于代码补全的插件

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  (use-package company
    :ensure t
    :init
    (global-company-mode t)                    ;; 全局开启 company 补全
    :config
    (setq company-idle-delay 0)                ;; 补全时间快些
    (setq company-minimum-prefix-length 1)     ;; 最少输入1个字符开启
    (setq company-show-numbers t)              ;; 给选项编号 (按快捷键 M-1、M-2 等等来进行选择)
    (setq company-dabbrev-other-buffers 'all)  ;; 从所有缓冲区收集补全信息
    (setq company-tooltip-align-annotations t) ;; 右侧附加注释
    (setq company-selection-wrap-around t)
    (setq company-transformers '(company-sort-by-occurrence)) ; 根据选择的频率进行排序，如果不喜欢可以去掉
    :bind (:map company-active-map
                ("C-n" . 'company-select-next)
                ("C-p" . 'company-select-previous)))  ;; 使用 `C-n` 与 `C-p` 来选择补全项，默认选择上一条和下一条候选项命令 M-n M-p
#+end_src

*** =init-completion.el= 增强 minibuffer 补全：vertico 和 Orderless
:PROPERTIES:
:CUSTOM_ID: h:completion-minibuffer-1
:END:

在学习章节提到过[[h:learn-completion-minibuffer-1][(增强 minibuffer 补全：vertico 和 Orderless)]]

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; 增强 minibuffer 补全：vertico 和 Orderless

  (use-package vertico
    :ensure t
    :init (vertico-mode))

  (use-package orderless
    :ensure t
    :after vertico
    :init (setq completion-styles '(orderless)))
#+end_src

有了 vertico-mode，把之前的 icomplete-mode 关掉。 补全变为垂直，垂直对于我们是更友好的，所有 minibuffer 的行为的可以补全。如使用 =M-x= 补全变为垂直,  =C-x C-f= 增强显示目录下文件、 =C-x b= 变为垂直。

orderless 支持 =M-x= 模糊搜索，可以无序的。 如 edebug-defun 函数搜索， =M-x fun debug=

*** =init-completion.el= 配置 Marginalia 增强 minubuffer 的 annotation
:PROPERTIES:
:CUSTOM_ID: h:completion-minibuffer-2
:END:

在学习章节提到过[[h:learn-completion-minibuffer-2][(配置 Marginalia 增强 minubuffer 的 annotation)]]

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; 配置 Marginalia 增强 minubuffer 的 annotation
  (use-package marginalia
    :ensure t
    :init (marginalia-mode)
  )
#+end_src

=M-x= 可以看到它会把命令的注释直接显示在minibuffer中

=C-h v= 查看一个变量的内容，可以发现不用再按回车看到里面的值。直接显示在minibuffer中

=C-h f= 键位绑定都已经在minibuffer中显示出来了

=C-x C-f= 显示文件大小权限等， =C-x b= 显 buffer 大小状态， =C-h f= 显示函数快捷键等

*** =init-completion.el= minibuffer action 和自适应的 context menu：Embark
:PROPERTIES:
:CUSTOM_ID: h:completion-minibuffer-3
:END:

在学习章节提到过[[h:learn-completion-minibuffer-3][(minibuffer action 和自适应的 context menu：Embar)]]

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; minibuffer action 和自适应的 context menu：Embark
  (use-package embark
    :ensure t
    :init
    ;; Optionally replace the key help with a completing-read interface
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    :bind
    (("C-;" . embark-act)         ;; pick some comfortable binding
     )) ;; alternative for `describe-bindings'
#+end_src

使用

光标在函数位置，按 =C-;= 
- RET 查看光标处函数定义文件位置，并打开
- c 修改变量的值
  - 如 C-h v 变量名，按 C-; c 修改变量的值

优点：不需要记快捷键了
- 以前查看函数的绑定键
  - ~C-h b~ 查看函数快捷键绑定：
  - 以前按 =C-x C-h= 时，会告诉你 =C-x= 绑定了哪些快捷键
- 设置了 =(setq prefix-help-command #'embark-prefix-help-command)= 后
  - 按 =C-x C-h= 模糊输入函数名可看到绑定的快捷键，按回车可直接执行命令，就不需要再记快捷键了

*** =init-completion.el= 增强文件内搜索Consult
:PROPERTIES:
:CUSTOM_ID: h:completion-minibuffer-4
:END:

在学习章节提到过[[h:learn-completion-minibuffer-4][(增强文件内搜索和跳转函数定义：Consult)]]

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; 增强文件内搜索和跳转函数定义：Consult
  (use-package consult
    :ensure t
    ;;replace swiper 可以替代老的 ivy mode 的 swiper 功能
    :bind (
           ("C-s" . consult-line) ;; replace swipe
           ("M-s i" . consult-imenu)  ;跳转函数定义
           ;;("C-x b" .  consult-buffer) ;; 多显示最近打开文件。替换默认 C-x b buffer
           ;;("C-c p s" . consult-ripgrep) ;;  查找文件内容，需要安装 ripgrep 命令
           )
    )
#+end_src

使用 =C-s= 搜索的内容就会在minibuffer中垂直显示，使用C-p 或 C-n来上下选择

使用 =M-s i= 跳转函数定义或者org-mode标题

这些组合可以秒杀ivy helm这种一统的插件。

**** =init-completion.el= 增强 embark 和 consult，批量搜索替换大杀器
:PROPERTIES:
:CUSTOM_ID: h:completion-minibuffer-4-1
:END:

在学习章节提到过[[#h:learn-completion-minibuffer-4-1][(增强 embark 和 consult，批量搜索替换大杀器)]]

性能： grep < ack < ag < ripgrep(rg)

使用ripgrep来进行搜索, =M-x consult-ripqgrep= 搜索hello 会出现报错找不到rg命令。

#+begin_example
Error running timer: (file-missing "Searching for program" "No such file or directory" "rg")
#+end_example

下载ripgrep: <https://github.com/BurntSushi/ripgrep> msys2 <https://packages.msys2.org/base/mingw-w64-ripgrep>

安装方式：
- PC msys2 ~pacman -S mingw-w64-x86_64-ripgrep~
- PC github release 下载windows包，解压并加入到PARH变量中
- Arch Linux  ~sudo pacman -S ripgrep~
- macOS ~brew install ripgrep~

再使用ripgrep来进行搜索, =M-x consult-ripgrep= 搜索hello ，所有当前目录下包含hello字符串的信息都在minibuffer中展示出来了。 使用 =C-n= 或 =C-p= 来预览文件或进入文件里。

*下面介绍批量修改插件*



#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; 批量修改文件内容
  (use-package embark-consult
    :ensure t)

  (use-package wgrep
    :ensure t)

  (setq wgrep-auto-save-buffer t)

  (eval-after-load 'consult
    '(eval-after-load 'embark
       '(progn
          (require 'embark-consult)
          (add-hook 'embark-collect-mode-hook #'consult-preview-at-point-mode)))) ;hook 第一个参数执行前，先执行第2个参数的功能

  (define-key minibuffer-local-map (kbd "C-c C-e") 'embark-export-write)
  #+end_src

批量替换操作
- ~M-x consult-ripgrep~  默认会在以 git 为根目录搜索。如 =#hello= ，搜索包含hello字符的文件。 ~C-n/C-p~ 下上搜索同时可以预览。
- ~C-c C-e~ 打开写
- ~M-x query-replace-regexp~ 输入hello 回车， 替换为hello 回车。 按 y 同意当前行替换，n 不同意修改
- ~C-c C-c~ 执行替换，按 q 退出


当前buffer替换操作
- =C-s= 搜索， 输入hello
- =C-c C-e= 编辑
- ~M-x query-replace-regexp~ 输入要替换的内容
- ~C-c C-c~ 执行替换，按 q 退出

*配置搜索中文文件*

everythin工具可以快速搜索本地文件。下载地址： <https://www.voidtools.com/zh-cn/downloads/>

安装好后，同时下载 ES.exe 客户端工具加入环境变量。

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  ;;; 配置搜索中文文件
  ;; PC提前安装 everyting 及其客户端ES. 利用M-x consult-locate搜索
  (progn
    (setq consult-locate-args (encode-coding-string "es.exe -i -p -r" 'gbk))
    (add-to-list 'process-coding-system-alist '("es" gbk . gbk))
    )
  (eval-after-load 'consult
    (progn
        (setq
          consult-narrow-key "<"
          consult-line-numbers-widen t
          consult-async-min-input 2         ;; 搜索 2 个字符显示输出。默认 3
          consult-async-refresh-delay  0.15
          consult-async-input-throttle 0.2
          consult-async-input-debounce 0.1)
        ))
#+end_src

操作：
- 前提：PC 始终打开everything, 转为ES会调用everthing
- =M-x consult-locate= 回车，输入要搜索的文件如 =#init.el= 。 可以看到minibuffer中显示的和everthing界面搜索的是一样的。
- 再输入个#号就可以使用 orderless 的功能进行过滤。如只想看29.4中init.el文件 =#init.el#29.4= 选中回车即可打开对应文件

使用外部程序打开：
- =M-x consult-locate= 回车，输入要搜索的文件. 如搜索projeckt中的txt文件 =#\.txt#project=
- 使用embark =C;=  按x使用外部程序打开txt文件

中文搜索操作：
- =M-x consult-locate= 回车，输入要搜索的文件. 如 =#学习=

*** =init-completion.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-completion.el"
  (message "Load init-completion done...")
  (provide 'init-completion)
#+end_src

** =init-tools.el=

*** =init-tools.el= config

#+begin_src emacs-lisp :tangle "lisp/init-tools.el" :mkdirp yes
  ;;; 窗口标签
  ;;(add-to-list 'load-path (expand-file-name "~/.emacs.d/site-lisp/awesome-tab/"))
  ;;(require 'awesome-tab)
  ;;(awesome-tab-mode t)

  (defun awesome-tab-buffer-groups ()
  "`awesome-tab-buffer-groups' control buffers' group rules.
  Group awesome-tab with mode if buffer is derived from `eshell-mode' `emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
  All buffer name start with * will group to \"Emacs\".
  Other buffer group by `awesome-tab-get-group-name' with project name."
  (list
  (cond
      ((or (string-equal "*" (substring (buffer-name) 0 1))
          (memq major-mode '(magit-process-mode
                              magit-status-mode
                              magit-diff-mode
                              magit-log-mode
                              magit-file-mode
                              magit-blob-mode
                              magit-blame-mode)))
      "Emacs")
      ((derived-mode-p 'eshell-mode)
      "EShell")
      ((derived-mode-p 'dired-mode)
      "Dired")
      ((memq major-mode '(org-mode org-agenda-mode diary-mode))
      "OrgMode")
      ((derived-mode-p 'eaf-mode)
      "EAF")
      (t
       (awesome-tab-get-group-name (current-buffer))))))
#+end_src

*** =init-tools.el= 使用拼音进行搜索
:PROPERTIES:
:CUSTOM_ID: h:tools-search-pinyin
:END:

在学习章节提到过[[#h:learn-tools-search-pinyin][(使用拼音进行搜索)]]

#+begin_src emacs-lisp :tangle "lisp/init-tools.el"
  ;;; 使用拼音进行搜索
  ;;ivy
  ;; Encoding
  ;; UTF-8 as the default coding system
  ;;(when (fboundp 'set-charset-priority)
  ;;  (set-charset-priority 'unicode))

  ;;(set-language-environment 'chinese-gbk)
  ;;(prefer-coding-system 'utf-8-auto)


  (use-package pyim
    :ensure t)

  (defun eh-orderless-regexp (orig_func component)
    (let ((result (funcall orig_func component)))
      (pyim-cregexp-build result)))


  (defun toggle-chinese-search ()
    (interactive)
    (if (not (advice-member-p #'eh-orderless-regexp 'orderless-regexp))
        (advice-add 'orderless-regexp :around #'eh-orderless-regexp)
      (advice-remove 'orderless-regexp #'eh-orderless-regexp)))

  (defun disable-py-search (&optional args)
    (if (advice-member-p #'eh-orderless-regexp 'orderless-regexp)
        (advice-remove 'orderless-regexp #'eh-orderless-regexp)))

  ;; (advice-add 'exit-minibuffer :after #'disable-py-search)
  (add-hook 'minibuffer-exit-hook 'disable-py-search) ;退出minibuffer时自动退出拼音搜索

  (global-set-key (kbd "s-p") 'toggle-chinese-search) ;需要时打开拼音搜索。因为拼音搜索性能不稳定
#+END_SRC

*** =init-tools.el= keycast
:PROPERTIES:
:CUSTOM_ID: h:tools-keycast
:END:

modeline上显示我的所有的按键和执行的命令

#+begin_src emacs-lisp :tangle "lisp/init-tools.el"
  ;;; modeline上显示我的所有的按键和执行的命令
  (use-package keycast
    :ensure t
    :init (keycast-mode-line-mode 1)) ; 在标题显示
#+end_src

在使用doom-modeline上面配置会报错。这里用下面的配置

*** =init-tools.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-tools.el"
  (message "Load init-tools done...")
  (provide 'init-tools)
#+end_src

** =init-ui.el=

*** =init-ui.el= 内置配置
:PROPERTIES:
:CUSTOM_ID: h:ui-built-in
:END:

在学习章节提到过[[h:learn-ui-built-in][(外观配置)]]

#+begin_src emacs-lisp :tangle "lisp/init-ui.el" :mkdirp yes
  (global-display-line-numbers-mode 1) ;显示行号 29版本。29之前用(global-linum-mode 1)
  (setq inhibit-startup-screen t) ; 尝试关掉启动界面
  ;;(toggle-frame-maximized)                     ; 全屏编辑器


  ;;(set-face-attribute 'default nil :height 150) ; 修改字号，大小为16pt
  ;;让鼠标滚动更好用。默认滚动很快
  (setq mouse-wheel-scroll-amount '(3 ((shift) . 1) ((control) . nil)))
  (setq mouse-wheel-progressive-speed nil)

  (tool-bar-mode -1)                           ;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
  (scroll-bar-mode -1)                         ;; 关闭文件滑动控件
  ;; (menu-bar-mode -1)                        ;; 关闭菜单栏 (不关闭，使用插件时会用到)

  (setq-default cursor-type 'bar)              ; 更改光标的样式，默认比较粗. 更多C-h v 查询帮助
  ;;(setq cursor-type 'bar)                    ;; 更改光标的样式。setq当前buffer生效，不能全局生效

  (global-hl-line-mode t)                      ;; 高亮当前行

  ;;主题
  ;;(load-theme 'tango-dark) ;这里使用doom-theme
#+end_src

*** =init-ui.el= doom-emacs
:PROPERTIES:
:CUSTOM_ID: h:ui-doom-emacs
:END:

#+begin_src emacs-lisp :tangle "lisp/init-ui.el"
  ;; 这里的执行顺序非常重要，doom-modeline-mode 的激活时机一定要在设置global-mode-string 之后‘
  (use-package doom-themes
    :ensure t)
  (load-theme 'doom-one 1)

  (use-package doom-modeline
    :ensure t
    :custom-face
    (mode-line ((t (:height 0.9))))
    (mode-line-inactive ((t (:height 0.9))))
    :init
    (doom-modeline-mode t))

  (use-package nerd-icons
    :ensure t)
#+end_src

现在更推荐用 [[https://github.com/rainstormstudio/nerd-icons.el][rainstormstudio/nerd-icons.el (github.com)]] 。直接下载一个nerd fonts就可以 (=M-x nerd-icons-install-fonts=)或者手动下载fonts目录中的 =NFM.ttf= 。GUI和terminal都可以显示icon，大小也更统一。

#+begin_src emacs-lisp :tangle no
  (use-package doom-themes
    :ensure t
    :init
    (if (display-graphic-p)
        (load-theme 'doom-solarized-light)
      (load-theme 'doom-tomorrow-night)))

  (use-package doom-modeline
    :ensure t
    :init
    (setq doom-modeline-minor-modes t)
    :custom-face
    (mode-line ((t (:height 0.95))))
    (mode-line-inactive ((t (:height 0.95))))
    :hook (after-init . doom-modeline-mode))
#+end_src

*** =init-ui.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-ui.el"
  (message "Load init-ui done...")
  (provide 'init-ui)
#+end_src

** =init-org.el=
:PROPERTIES:
:CUSTOM_ID: h:org
:END:

*** =init-org.el= 内置配置
:PROPERTIES:
:CUSTOM_ID: h:org-built-in
:END:

在学习章节提到过[[h:learn-org-built-in][(还想使用旧版快捷)]]

#+begin_src emacs-lisp :tangle "lisp/init-org.el" :mkdirp yes
  ;;; config

  ;;; 使用旧版快捷键<s +Tab
  (with-eval-after-load 'org
    (require 'org-tempo))

  ;; 禁用左尖括号
  (setq electric-pair-inhibit-predicate
        `(lambda (c)
           (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))

  (add-hook 'org-mode-hook
            (lambda ()
              (setq-local electric-pair-inhibit-predicate
                          `(lambda (c)
                             (if (char-equal c ?\<) t (,electric-pair-inhibit-predicate c))))))
#+end_src

*** =init-org.el= 安装最新org包

#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  ;;; 安装 org，这个配置一定要配置在 use-package 的初始化之前，否则无法正常安装
  (assq-delete-all 'org package--builtins)
  (assq-delete-all 'org package--builtin-versions)
  (use-package org
    :pin gnu-elpa
    :ensure t)

  (use-package org-contrib  ;非org的官方贡献的插件
    :ensure t
    :pin nongnu)

 

#+end_src

*** =init-org.el= org todo
:PROPERTIES:
:CUSTOM_ID: h:org-todo
:END:


#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  ;;; 自定义org todo  C-c C-t 
  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d!/!)")
                (sequence "WAITING(w@/!)" "SOMEDAY(S)" "|" "CANCELLED(c@/!)" "MEETING(m)" "PHONE(p)"))))
#+end_src

以上代码让你在为一个标题提供待办事项状态时添加了一个键序列，你可以键入 =C-c C-t= 来查看效果。

其中 =@= 代表记录日志，而 =!= 代表记录时间戳，你也可以让他们具有两种功能: =TODO(t@/!)=

*任务进度* ：

创建文件 =~/gtd.org=
#+begin_src org
,* WAITING Daily routine
- [ ] leetcode
- [ ] execrcise
#+end_src


#+begin_src org
,* TODO Daily routine [100%]
SCHEDULED: <2022-06-10 Fri 10:00 +1d>
:PROPERTIES:
:LAST_REPEAT: [2022-06-09 Thu 02:31]
:END:
- State "DONE"       from "TODO"       [2022-06-09 Thu 02:31]
- State "TODO"       from "WAITING"    [2022-06-09 Thu 02:26]
- [X] leetcode
- [X] execrcise
#+end_src

- =C-c C-s= 开始计划： =<2022-06-09 Thu 10:00>= 10点
  
- 每天 10 点做：需要 =+d= 加一天 =SCHEDULED: <2022-06-09 Thu 10:00 +1d>= ，后面在 agenda 中会用到
  
- 完成情况进度：每一项任务使用复选框，todo 部分加 =[%]= ，复选框使用 =C-c C-c= 打 叉 表示完成。

标记完成：=C-c C-t d= ，可以看到 =SCHEDULED= 时间自动加 1 =SCHEDULED: <2022-06-10 Fri 10:00 +1d>=

#+begin_src org
  ,* TODO Daily routine [100%]
  SCHEDULED: <2022-06-10 Fri 10:00 +1d>
  :PROPERTIES:
  :LAST_REPEAT: [2022-06-09 Thu 02:31]
  :END:
  - State "DONE"       from "TODO"       [2022-06-09 Thu 02:31]
  - State "TODO"       from "WAITING"    [2022-06-09 Thu 02:26]
  - [X] leetcode
  - [X] execrcise
#+end_src

不过进入新的计划，每一项还需要新状态。这很麻烦，所以这边用另一个插件包 org-contrib。
目的是要引入 check list

#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  (require 'org-checklist)
  ;; need repeat task and properties
  (setq org-log-done t)
  (setq org-log-into-drawer t)
#+end_src

通过 =M-x org-set-property=  添加 =RESET_CHECK_BOXES= 。 =RESET_CHECK_BOXES=  设置为 =t= 开启， 会在 =PROPERTIES= 中增加属性。

当 =C-c C-t d= 把标题设置为 DONE，自动进入下一个时间点。 这对自定义一些重复性工作比较方便。


#+begin_src org
  ,* TODO Daily routine [0%]
  SCHEDULED: <2022-06-15 Wed 10:00 +1d>
  :PROPERTIES:
  :LAST_REPEAT: [2022-06-09 Thu 07:24]
  :RESET_CHECK_BOXES: t
  :END:
  - State "DONE"       from "TODO"       [2022-06-09 Thu 07:24]
  - State "DONE"       from "TODO"       [2022-06-09 Thu 02:31]
  - State "TODO"       from "WAITING"    [2022-06-09 Thu 02:26]
  - [ ] leetcode
  - [ ] execrcise
#+end_src

每次完成任务会自动插入完成状态，使用下面设置可以隐藏到 =PROPERTIES= 里：
#+begin_src emacs-lisp :tangle no
;; need repeat task and properties
(setq org-log-done t)
(setq org-log-into-drawer t)
#+end_src

使用 =C-c C-t d= 完成任务， 完成状态会增加到 =LOGBOOK= 属性中。把之前的状态手动移过来。
#+begin_src org
,* TODO Daily routine [0%]
SCHEDULED: <2022-06-17 Fri 10:00 +1d>
:PROPERTIES:
:LAST_REPEAT: [2022-06-09 Thu 07:44]
:RESET_CHECK_BOXES: t
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-06-09 Thu 07:44]
- State "DONE"       from "TODO"       [2022-06-09 Thu 07:34]
- State "DONE"       from "TODO"       [2022-06-09 Thu 07:24]
- State "DONE"       from              [2022-06-09 Thu 03:03]
- State "DONE"       from              [2022-06-09 Thu 02:50]
- State "DONE"       from "TODO"       [2022-06-09 Thu 02:31]
- State "TODO"       from "WAITING"    [2022-06-09 Thu 02:26]  
:END:
- [ ] leetcode
- [ ] execrcise
#+end_src

*** =init-org.el= org agenda
:PROPERTIES:
:CUSTOM_ID: h:org-agenda
:END:


相当于有一个日历实时告诉你每天要做什么。通过 =M-x org-agenda= 来打开. 这里需要一个存放日程的目录，同时绑定快捷键 =C-c a= 方便查看。


#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  ;; C-c C-s schedule
  ;; C-c C-d deadline
  (global-set-key (kbd "C-c a") 'org-agenda)
  (setq org-agenda-files '("~/gtd.org")) ;; 定义 agenda 文件，可以是多个
  (setq org-agenda-span 'day) ;; 按天观察
#+end_src

基本操作：
- =C-c a a=  可以看到每周日程。
- =f/b= 下一个/上一个阶段安排, =d/w= 天/周视图，=n/p= 上/下移动光标 
- 在 =~/gtd.org= 设置 deadline =C-c C-d= ，在日程中也能看到。
  
*** =init-org.el= org capture
:PROPERTIES:
:CUSTOM_ID: h:org-capture
:END:

#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "~/gtd.org" "Workspace")
           "* TODO [#B] %?\n  %i\n %U"
           :empty-lines 1)))

  (global-set-key (kbd "C-c r") 'org-capture)
#+end_src

这个模板包含五个部分，分别是

| 模板组成     | 对应默认模板中的内容                      | 描述             |
| key         | "t"                                     | 用来选择模板的字符 |
| description | "Todo"                                  | 展示用的模板描述   |
| type        | entry                                   | 新增内容的类型    |
| target      | (file+headline "~/gtd.org" "Workspace") | 新增内容的存储位置 |
| template    | "* TODO [#B] %?\n  %i\n %U"             | 新增内容的模板    |

新增内容的模板:
- "%?" 是一个更特殊的标记，它不会产生任何内容，当所有其他的特殊标记都展开完毕或者输入完毕后，光标将会停留在这个标记所在的位置。
- %i 可以插入一段初始化内容
- %U  当前包含日期和时间的未激活的 timestamp，如: [2018-03-04 日 19:26] 

定义捕获模板，绑定到快捷键 =C-c r= 。 更写详细的参考官方文档。

操作：
- =C-c a t= 向指定文件中写内容。 =C-c C-c= 完成. 会记录到gtd.org文件中
- 在文件中设置开始时间 =C-c C-s= 21:00 点， 再执行 =C-c a a= 就可看到日程更新了。

*** =init-org.el= org effect
:PROPERTIES:
:CUSTOM_ID: h:org-effect
:END:


设置任务完成需要的时间。

在 agenda view 中,  =e= 键可以设置effort, 按 =_= (org-agenda-filter-by-effort) 可以过滤指定effort 的heading

范例:设置 30分钟任务
- 进入agenda =C-c a a=
- 设置完成任务需要30分钟，按 =e= 输入 =00:30= 
- 过滤 1 小时内能完成任务，按 =_=  输入 =<= 选择 [4]1:00 对应的数字 4

*** =init-org.el= org tags
:PROPERTIES:
:CUSTOM_ID: h:org-tags
:END:


在 agenda view 中添加tag, 使用 =:= , 也可以 =M-x org-agenda-set-tags= 添加。

*** =init-org.el= org priority
:PROPERTIES:
:CUSTOM_ID: h:org-priority
:END:


#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  (setq org-agenda-custom-commands
        '(("c" "重要且紧急的事"
           ((tags-todo "+PRIORITY=\"A\"")))
          ;; ...other commands here
          ))
#+end_src

*** =init-org.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-org.el"
  (message "Load init-org done...")
  (provide 'init-org)
#+end_src

** =init-keybindings.el=

*** =init-keybindings.el= config

#+begin_src emacs-lisp :tangle "lisp/init-keybindings.el" :mkdirp yes
  ;;; config

#+end_src

*** =init-keybindings.el= 文件搜索
:PROPERTIES:
:CUSTOM_ID: h:keybindings-search-file
:END:

配置划分成不同文件，好以后方式方便查找

#+begin_src emacs-lisp :tangle "lisp/init-keybindings.el"
  ;;; 文件搜索
  (global-set-key (kbd "C-c p f") 'project-find-file) ;;   查找文件，默认绑定在 C-x p f
  (eval-after-load 'consult (global-set-key (kbd "C-c p s") 'consult-ripgrep))  ;;  查找文件内容
#+end_src

C-c 是给用户定义的快捷键，p 代表 project ， f 代表 find-file

consult-ripgrep 需要安装 consult 和 ripgrep ， 方便查找关键字

操作：快速找到文件
- =C-c p f= 选择目标目录, 回车 如 =~/.emacs.d=
- 输入要查找文件名对应的关键字符，即可打开文件。 如打开 =~/.emacs.d/lisp/init-basic.el= 文件， 输入basic即可

*** =init-keybindings.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-keybindings.el"
  (message "Load init-keybindings done...")
  (provide 'init-keybindings)
#+end_src

** =init-programming.el=

*** =init-programming.el= c++
:PROPERTIES:
:CUSTOM_ID: h:c++
:END:

**** 使用 eglot 来编写、运行和调试 C/C++ 代码
:PROPERTIES:
:CUSTOM_ID: h:c++-eglot
:END:

*安装 mysys2*

1.下载 https://www.msys2.org/

2.安装 C/C++ 必要的软件工具

#+begin_src sh :tangle no
  #安装c++必要软件 gcc gdb make clang clang-tool
  pacman -Syu
  pacman -S mingw-w64-x86_64-gcc mingw-w64-x86_64-gdb make mingw-w64-x86_64-clang mingw-w64-x86_64-clang-tools-extra
#+end_src

3.设置环境变量
#+begin_example
d:\msys64\mingw64\bin
d:\msys64\usr\bin
#+end_example

*安装 eglot(Emacs 29 自带 eglot)*


#+begin_src emacs-lisp :tangle "lisp/init-programming.el" :mkdirp yes
  ;;; c++ eglot
  (require 'eglot)
  (add-to-list 'eglot-server-programs '((c++-mode c-mode) "clangd"))
  (add-hook 'c-mode-hook #'eglot-ensure)
  (add-hook 'c++-mode-hook #'eglot-ensure)
#+end_src

测试一段c++代码

=~/test.cpp=
在emacs菜单栏flymake可以列出所有问题

*一键运行代码*

1.安装 quickrun:

可以运行任意一个单文件程序
#+begin_src emacs-lisp :tangle "lisp/init-programming.el"
    ;;运行任意单文件程序 快捷键F5
    (use-package quickrun
      :ensure t
      :commands (quickrun)
      :init
      (quickrun-add-command "c++/c1z"
        '((:command . "g++")
          (:exec . ("%c -std=c++1z %o -o %e %s"
                    "%e %a"))
          (:remove . ("%e")))
        :default "c++"))
    (global-set-key (kbd "<f5>") 'quickrun)
#+end_src

*使用 gdb 调试*

1. 运行 =M-x compile=, 输入 g++ -g -o test.o test.cpp #-g编译时生成调试信息
2. 使用 =M-x gud-gdb= 输入 gdb ./test.o
3. 常用调试命令

| name            | function                                            |
| list            | 显示源代码                                           |
| break           | 新增断点， break main, break 12（行号）               |
| info            | 查看断点或者局部变量信息 info breakpoints, info locals |
| run             | 开始调试                                             |
| next            | 类似 step over                                      |
| step            | 跳转到函数内部                                       |
| continue        | 继续运行到下一个断点                                  |
| quit            | 退出调试                                             |
| watch           | 内存断点                                             |
| display         | 类似 IDE 里面的 watch 功能                           |
| break 11 if xxx | 条件断点                                             |


- list 显示源代码
- break 11 在第11行打断点
- break 12 在第12行打断点.
  - 如果有函数名add，也可以给函数下断点 b add;
  - 条件断点 b 20 if i == 2500 在第20行i等于时加断点
- info breakpoints 查看断点信息
- run 调试，程序停在第一个断点位置
- print myVec的值
- next下一个
- print myVec的值,发生变化
- continue 运行到下一个断点

#+begin_example
  (gdb) list
  1	#include<iostream>
  2	#include<iterator>
  3	#include<vector>
  4	
  5	using namespace std;
  6	
  7	int main()
  8	{
  9	  vector<int> myVec;
  10	  myVec.push_back(2);
  (gdb) 
  11	  myVec.push_back(3);
  12	  cout << "Hello World"<<endl;
  13	  
  14	  cout <<"vect size: "<<myVec.size() <<endl;
  15	  return 0;
  16	}
  (gdb) break 11
  Breakpoint 1 at 0x140001483: file test.cpp, line 11.
  (gdb) break 12
  Breakpoint 2 at 0x14000149a: file test.cpp, line 12.
  (gdb) info breakpoints
  Num     Type           Disp Enb Address            What
  1       breakpoint     keep y   0x0000000140001483 in main() at test.cpp:11
  2       breakpoint     keep y   0x000000014000149a in main() at test.cpp:12
  (gdb) run
  Starting program: d:\tmp\emacs\test.o 
  [New Thread 7812.0x4d34]
  [New Thread 7812.0x4864]
  [New Thread 7812.0x3bdc]

  Thread 1 hit Breakpoint 1, main () at test.cpp:11
  11	  myVec.push_back(3);
  (gdb) print myVec
  $1 = std::vector of length 1, capacity 1 = {2}
  (gdb) next

  Thread 1 hit Breakpoint 2, main () at test.cpp:12
  12	  cout << "Hello World"<<endl;
  (gdb) print myVec
  $2 = std::vector of length 2, capacity 2 = {2, 3}
  (gdb) continue
  Continuing.
  Hello World
  vect size: 2
  [Thread 7812.0x4d34 exited with code 0]
  [Thread 7812.0x4864 exited with code 0]
  [Thread 7812.0x3bdc exited with code 0]
  [Inferior 1 (process 7812) exited normally]
  (gdb) 
#+end_example

*** =init-programming.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-programming.el"
  (message "Load init-programming done...")
  (provide 'init-programming)
#+end_src

** =init-evil.el=

*** =init-evil.el= 安装
:PROPERTIES:
:CUSTOM_ID: h:evil-init
:END:


#+begin_src emacs-lisp :tangle no :results none
  ;;; evil 
  (use-package evil
    :ensure t
    :init
    (setq evil-want-keybinding nil) ;不使用自带的键位绑定。默认加载不同模式下键位绑定
    (setq evil-want-C-u-scroll t) ;C-u 实现向上滚动。默认C-u 是emacs中的功能
    (evil-mode)

    ;; https://emacs.stackexchange.com/questions/46371/how-can-i-get-ret-to-follow-org-mode-links-when-using-evil-mode
    (with-eval-after-load 'evil-maps
      (define-key evil-motion-state-map (kbd "RET") nil)) ;如果有链接，按回车能访问这个链接
    )
#+end_src


安装undo-tree
#+begin_src emacs-lisp :tangle no :results none
  ;;; evil 使用undo-tree来管理undo redo
  (use-package undo-tree
    :diminish
    :init
    (global-undo-tree-mode 1)
    (setq undo-tree-auto-save-history nil)
    (evil-set-undo-system 'undo-tree))
#+end_src

*Emacs中使用vim和外部使用vim的区别*

vim 中有normal和insert模式，在emacs中是各种state, 如 noarmal state, insert state

- Normal State (N) :: 这是 Evil 默认的“静止状态”，其中定义了 vi 绑定的主体。 =M-x evil-normal-state=

- Insert State (I) :: 这是插入文本的状态，其中未修改的键将在缓冲区中插入相应的字符。

- Emacs State (E) :: 一种尽可能接近默认 Emacs 行为的状态，通过 =C-z= 从emacs和 vi 相互切换。

- Visual State (V) :: 用于选择文本区域的状态。

- Motion State (M) 运动状态 （M） :: 一种特殊状态，适用于只读缓冲区，其中运动可用，但编辑操作不可用。只读的文档一般都是Motion state 如帮助文档。 =M-x evil-motion-state=

- Replace State (R) 替换状态 （R） :: 一种特殊状态，与插入状态非常相似，只不过它替换文本而不是插入。 按住大写的 =R= , 一直替换状态


*Evil 基础用法*

增删改查 (text-obj, commands, replace)
- text-obj 更好地操作文本
  - 选中单词 viw
  - 删除单词 diw
- 跳到r字符的位置： fr
- commands
  - =:= 进行命令行模式。 :%s/commands/111/ 可以替换, 按 u 回退 
    
evil-guide: <https://github.com/noctuid/evil-guide.git>

上述文档花2小时认真读就可以完全从vim用户切到emacs上使用了。

比较全的evil配置
#+begin_src emacs-lisp :tangle "lisp/init-evil.el" :mkdirp yes
  ;;; evil 
  (use-package evil
    :ensure t
    :init
    (setq evil-want-keybinding nil) ;不使用自带的键位绑定。默认加载不同模式下键位绑定
    (setq evil-want-C-u-scroll t) ;C-u 实现向上滚动。默认C-u 是emacs中的功能
    (evil-mode)

    ;; https://emacs.stackexchange.com/questions/46371/how-can-i-get-ret-to-follow-org-mode-links-when-using-evil-mode
    (with-eval-after-load 'evil-maps
      (define-key evil-motion-state-map (kbd "RET") nil)) ;如果有链接，按回车能访问这个链接

    ;;; 自定义设置
    ;; 在进行插入模式后，希望使用emacs的快捷键，而又不希望进入 Emacs State
    (setcdr evil-insert-state-map nil)
    (define-key evil-insert-state-map [escape] 'evil-normal-state) ;按 [Esc] 回到normal state. 下面会介绍更方便的evil-escape插件

    ;; 加空行, 默认 o + Esc 需要2次操作. 下面的设置直接在normal 模式中操作
    (define-key evil-normal-state-map (kbd "[ SPC") (lambda () (interactive) (evil-insert-newline-above) (forward-line))) ; 向上加空行
    (define-key evil-normal-state-map (kbd "] SPC") (lambda () (interactive) (evil-insert-newline-below) (forward-line -1))) ; 向上加空行

    ;; 在normal state中切换不同的buffer
    (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer) ;切到前一个buffer
    (define-key evil-normal-state-map (kbd "] b") 'next-buffer)
    (define-key evil-motion-state-map (kbd "[ b") 'previous-buffer)
    (define-key evil-motion-state-map (kbd "] b") 'next-buffer)

    ;; 在dired模式下，添加快捷键
    (evil-define-key 'normal dired-mode-map ; 只修改dired模式下normal模式的快捷键绑定
      (kbd "<RET>") 'dired-find-alternate-file
      (kbd "C-k") 'dired-up-directory ;往上一级目录
      "`" 'dired-open-term
      "q" 'quit-window ; q 退出。默认没有。 可以查看emacs state下的q绑定的函数 =C-x d= 进入dired， =C-z= 进入emacs state， =C-h k= 按 q 可查到对应的函数为 quit-window
      "o" 'dired-find-file-other-window ; 在另外一个窗口打开文件
      "z" 'dired-get-size
      ")" 'dired-omit-mode)
    )





  ;;; evil 使用undo-tree来管理undo redo
  (use-package undo-tree
    :ensure t
    :diminish
    :init
    (global-undo-tree-mode 1)
    (setq undo-tree-auto-save-history nil)
    (evil-set-undo-system 'undo-tree))
#+end_src

*** =init.evil.el= 自定义快捷键
:PROPERTIES:
:CUSTOM_ID: h:evil-custom-keybinding
:END:


*定义不同 state 下面的快捷键*


#+begin_src emacs-lisp :tangle no :results none
  ;;; 自定义设置
  ;; 在进行插入模式后，希望使用emacs的快捷键，而又不希望进入 Emacs State
  (setcdr evil-insert-state-map nil)
  (define-key evil-insert-state-map [escape] 'evil-normal-state) ;按 [Esc] 回到normal state

  ;; 加空行, 默认 o + Esc 需要2次操作. 下面的设置直接在normal 模式中操作
  (define-key evil-normal-state-map (kbd "[ SPC") (lambda () (interactive) (evil-insert-newline-above) (forward-line))) ; [ + 空格，向上加空行
  (define-key evil-normal-state-map (kbd "] SPC") (lambda () (interactive) (evil-insert-newline-below) (forward-line -1))) ; [ + 空格，向上加空行

  ;; 在normal state中切换不同的buffer
  (define-key evil-normal-state-map (kbd "[ b") 'previous-buffer) ; [ + b 切到前一个buffer
  (define-key evil-normal-state-map (kbd "] b") 'next-buffer)
  (define-key evil-motion-state-map (kbd "[ b") 'previous-buffer)
  (define-key evil-motion-state-map (kbd "] b") 'next-buffer)

  ;; 在dired模式下，添加快捷键
  (evil-define-key 'normal dired-mode-map ; 只修改dired模式下normal模式的快捷键绑定
    (kbd "<RET>") 'dired-find-alternate-file
    (kbd "C-k") 'dired-up-directory ;往上一级目录
    "`" 'dired-open-term
    "q" 'quit-window ; q 退出。默认没有。 可以查看emacs state下的q绑定的函数 =C-x d= 进入dired， =C-z= 进入emacs state， =C-h k= 按 q 可查到对应的函数为 quit-window
    "o" 'dired-find-file-other-window ; 在另外一个窗口打开文件
    "z" 'dired-get-size
    ")" 'dired-omit-mode)
#+end_src


*spacemacs like 快捷键如何定义*

general插件中global-definer在init-basic.el中定义[[#h:basic-general][(=init-basic.el= general)]]

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  (use-package general
    :init
    ;; global-definer 对应leader键为空格
    (global-definer
      "!" 'shell-command ;空格+! SPC ! 进入shell命令行
      "SPC" 'execute-extended-command ; 按2下空格SPC-SPC就可以实现 M-x 的效果
      "'" 'vertico-repeat
      "+" 'text-scale-increase
      "-" 'text-scale-decrease
      "u" 'universal-argument ;SPC u 相当于emacs的C-u 
      "hdf" 'describe-function ;SPC hdf 相当于emacs的C-h f
      "hdv" 'describe-variable ;SPC hdv 相当于emacs的C-h v
      "hdk" 'describe-key ;SPC hdk 相当于emacs的C-h k
      )
    ;; leader 键为SPC空格，子leader键为b. 如 SPC b b查看buffer缓冲区
    (+general-global-menu! "buffer" "b"
      "d" 'kill-current-buffer
      "b" '(consult-buffer :which-key "consult buffer") ; 查看buffer缓冲区
      "B" 'switch-to-buffer
      "p" 'previous-buffer
      "R" 'rename-buffer
      "M" '((lambda () (interactive) (switch-to-buffer "*Messages*")) 
            :which-key "messages-buffer") ; SPC b M查看*Message*缓冲区
      "n" 'next-buffer
      "i" 'ibuffer
      "f" 'my-open-current-directory
      "k" 'kill-buffer

      "y" 'copy-buffer-name
      "K" 'kill-other-buffers)
    )
#+end_src

参考配置： https://github.com/zilongshanren/emacs.d/blob/eglot/lisp/init-keybindings.el 实现自己的文件、窗口、项目多种快捷键绑定

*** 相关插件列表

**** evil-escape插件回退到normal state

任何状态下按 =kj= 就能回到normal state。很实用，相当于把esc键集中在右手, 一只手就可以操作vim常用功能。
#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;; kj 退回到普通模式
  (use-package evil-escape
    :ensure t
    :init
    ;; {{ https://github.com/syl20bnr/evil-escape
    (setq-default evil-escape-delay 0.3)
    (setq evil-escape-excluded-major-modes '(dired-mode))
    (setq-default evil-escape-key-sequence "kj")
    ;; disable evil-escape when input method is on
    (evil-escape-mode 1)
    ;; }}
  )
#+end_src

**** evil-anzu

小功能ui。 当用 =Shift *= 查找单词重复出现几次时，下方状态栏会多一个标识显示，显示当前重复出现单词的位置和总重复次数。
#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;;下方状态栏显示单词重复出现位置
  (use-package evil-anzu
    :ensure t
    :after evil
    :diminish
    :demand t
    :init
    (global-anzu-mode t))
#+end_src

**** evil-collections

使用社区的按键绑定。相对稳定不会改变

同时可以设置不同模式中默认的evil状态

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;;; 使用社区稳定的按键绑定。 并设置不同模式中默认的evil状态
  (use-package evil-collection
    :ensure t
    :demand t
    :config
    (setq evil-collection-mode-list (remove 'lispy evil-collection-mode-list)) ; 移除社区中插件的改键对你键位影响
    (evil-collection-init)

    ;; 设置进入mode时对应的vim 模式
    (cl-loop for (mode . state) in
             '((org-agenda-mode . normal) ;进入agenda时默认Normal State状态
               (Custom-mode . emacs)
               (eshell-mode . emacs) ;进入eshell模式时默认Emacs State状态
               (makey-key-mode . motion))
             do (evil-set-initial-state mode state)))
#+end_src

**** evil-surround

S用法，选中一个单词后加引号。
- =viw S "= 相当于原生vim text object用法 =viw Shift i "= 操作 

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;;; S用法，选中一个单词后加引号。viw S " 相当于原生vim text object用法 viw Shift i " 
  (use-package evil-surround
    :ensure t
    :init
    (global-evil-surround-mode 1))
#+end_src

**** evil-nerd-commenter

对不同语言加的注释

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;;; 添加不同语言的注释
  (use-package evil-nerd-commenter
    :init
    ;; normal 或 visual 模式下按 ,/ 可加注释
    ;; (define-key evil-normal-state-map (kbd ",ci") 'evilnc-comment-or-uncomment-lines)
    (define-key evil-normal-state-map (kbd ",/") 'evilnc-comment-or-uncomment-lines)
    (define-key evil-visual-state-map (kbd ",") 'evilnc-comment-or-uncomment-lines)
    )
#+end_src

操作：加注释
- 单行注释， =,/=
- 多行注释，选中行 =,/=

**** evil-snipe

小功能ui。高亮查找的字符。 如查找m字符。 =fm= 当前行的m字符高亮。按 =;= 重复查找动作
#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
(use-package evil-snipe
  :ensure t
  :diminish
  :init
  (evil-snipe-mode +1)
  (evil-snipe-override-mode +1))
#+end_src

**** evil-matchit

按 =%= 可以在函数、括号之间跳转

参考我的文章[[http://xuchangwei.com/lisp/coding-emacs/coding-emacs.html#h:vscode-symbol-jump][(如何提高编程速度)]]

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  ;;; 按 % 可以在函数、括号之间跳转
  (use-package evil-matchit
    :ensure
    :init
    (global-evil-matchit-mode 1))
#+end_src

*** 高阶用法（自定义 text-obj 或者 自定义 commands)

- https://github.com/noctuid/evil-guide#modes
- https://evil.readthedocs.io/en/latest/overview.html

*** =init-evil.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-evil.el"
  (message "Load init-evil done...")
  (provide 'init-evil)
#+end_src

** =init-window.el=

*** =init-window.el= config

#+begin_src emacs-lisp :tangle "lisp/init-window.el" :mkdirp yes
  ;;; config

#+end_src
*** =init-window.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-window.el"
  (message "Load init-window done...")
  (provide 'init-window)
#+end_src

** =init-funcs.el=


#+begin_src emacs-lisp :tangle "lisp/init-funcs.el" :mkdirp yes
  ;;; 快速打开配置文件
  (defun open-init-file()
    (interactive)
    (find-file "~/.emacs.d/init.el"))

  ;; 这一行代码，将函数 open-init-file 绑定到 <f4> 键上
  (global-set-key (kbd "<f4>") 'open-init-file)


  ;;; 批量写
  (defun embark-export-write ()
    "Export the current vertico results to a writable buffer if possible.
  Supports exporting consult-grep to wgrep, file to wdeired, and consult-location to occur-edit"
    (interactive)
    (require 'embark)
    (require 'wgrep)
    (pcase-let ((`(,type . ,candidates)
                 (run-hook-with-args-until-success 'embark-candidate-collectors)))
      (pcase type
        ('consult-grep (let ((embark-after-export-hook #'wgrep-change-to-wgrep-mode))
                         (embark-export)))
        ('file (let ((embark-after-export-hook #'wdired-change-to-wdired-mode))
                 (embark-export)))
        ('consult-location (let ((embark-after-export-hook #'occur-edit-mode))
                             (embark-export)))
        (x (user-error "embark category %S doesn't support writable export" x)))))
#+end_src

*** =init-funcs.el= 超级前端-打开PC文件管理器
:PROPERTIES:
:CUSTOM_ID: h:funcs-front-explorer
:END:
在学习章节提到过[[#h:learn-funcs-front-explorer][(使用 Emacs 来打开文件管理器)]]

#+begin_src emacs-lisp :tangle "lisp/init-funcs.el"
  ;;; 使用 Emacs 来打开文件管理器
  (defun consult-directory-externally (file)
    "Open FILE externally using the default application of the system."
    (interactive "fOpen externally: ")
    (if (and (eq system-type 'windows-nt)
             (fboundp 'w32-shell-execute))
        ;;(shell-command-to-string (encode-coding-string (replace-regexp-in-string "/" "\\\\\\\\"
        (shell-command-to-string (encode-coding-string (replace-regexp-in-string "/" "\\\\"
              (format "explorer.exe %s" (file-name-directory (expand-file-name file)))) 'gbk))
      (call-process (pcase system-type
                      ('darwin "open")
                      ('cygwin "cygstart")
                      (_ "xdg-open"))
                    nil 0 nil
                    (file-name-directory (expand-file-name file)))))

  (require 'embark)
  (define-key embark-file-map (kbd "E") #'consult-directory-externally)

  ;;打开当前文件的目录
  (defun my-open-current-directory ()
    (interactive)
    (consult-directory-externally default-directory))
#+end_src

*** =init-funcs.el= 调用 provide

#+begin_src emacs-lisp :tangle "lisp/init-funcs.el"
  (message "Load init-funcs done...")
  (provide 'init-funcs)
#+end_src

